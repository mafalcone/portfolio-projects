#!/usr/bin/env python3

import requests
import ssl
import socket
import argparse
import json
from urllib.parse import urlparse
from datetime import datetime, timezone
from pathlib import Path

SECURITY_HEADERS = [
    "Content-Security-Policy",
    "Strict-Transport-Security",
    "X-Frame-Options",
    "X-Content-Type-Options",
    "Referrer-Policy",
    "Permissions-Policy",
]

def get_https_info(host):
    ctx = ssl.create_default_context()
    with socket.create_connection((host, 443), timeout=5) as sock:
        with ctx.wrap_socket(sock, server_hostname=host) as ssock:
            cert = ssock.getpeercert()
            return {
                "tls_version": ssock.version(),
                "issuer": dict(x[0] for x in cert.get("issuer", [])),
                "expires": cert.get("notAfter"),
            }


def check_http_redirect(host):
    try:
        r = requests.get(f"http://{host}", allow_redirects=False, timeout=5)
        loc = r.headers.get("Location", "")
        return loc.startswith("https://")
    except Exception:
        return False

def check_http_to_https_redirect(url):
    parsed = urlparse(url)
    if not parsed.hostname:
        return None
    http_url = f"http://{parsed.hostname}{parsed.path or ''}"
    if parsed.query:
        http_url += "?" + parsed.query
    try:
        r = requests.get(http_url, timeout=10, allow_redirects=False)
        loc = r.headers.get("Location", "")
        return bool(loc.startswith("https://"))
    except Exception:
        return None


def audit(url):
    result = {
        "url": url,
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "headers": {},
        "cookies": [],
        "https": {},
        "checks": {},
        "leaks": [],
        "score": 100,
        "recommendations": [],
        "additional_checks": {}

    # Additional checks
    result["additional_checks"] = {}
    }

    r = requests.get(url, timeout=10)
    headers = r.headers

    # Security headers
    for h in SECURITY_HEADERS:
        if h in headers:
            result["headers"][h] = "present"
        else:
            result["headers"][h] = "missing"
            result["score"] -= 8
            result["recommendations"].append(f"Missing security header: {h}")

    # Cookies
    for c in r.cookies:
        flags = {
            "secure": c.secure,
            "httponly": "HttpOnly" in c._rest,
            "samesite": c._rest.get("SameSite")
        }
        result["cookies"].append({c.name: flags})
        if not flags["secure"]:
            result["score"] -= 5
            result["recommendations"].append(f"Cookie {c.name} is not Secure")

    # Info leakage
    for leak in ["Server", "X-Powered-By"]:
        if leak in headers:
            result["leaks"].append({leak: headers[leak]})
            result["score"] -= 5
            result["recommendations"].append(f"Information leak header exposed: {leak}")

    parsed = urlparse(url)

    # HTTPS + TLS
    if parsed.scheme != "https":
        result["score"] -= 20
        result["recommendations"].append("Site is not using HTTPS")
    else:
        try:
            https_info = get_https_info(parsed.hostname)
            result["https"] = https_info

            tls = https_info.get("tls_version", "")
            result["checks"]["tls_version"] = tls

            if tls in ("TLSv1", "TLSv1.1"):
                result["score"] -= 15
                result["recommendations"].append(f"Insecure TLS version supported: {tls}")

        except Exception:
            result["score"] -= 10
            result["recommendations"].append("HTTPS certificate / TLS issue")

    # HTTP â†’ HTTPS redirect
    redirect_ok = check_http_redirect(parsed.hostname)
    result["checks"]["http_to_https_redirect"] = redirect_ok
    if not redirect_ok:
        result["score"] -= 10
        result["recommendations"].append("HTTP does not properly redirect to HTTPS")

    result["score"] = max(result["score"], 0)
    return result

def render_html(data, path):
    # Minimal, portfolio-friendly report (dark card style)
    def li(label, value, good_when_present=False):
        if good_when_present:
            cls = "good" if value == "present" else "bad"
        else:
            cls = "good" if value in (True, "true", "yes") else "bad"
        return f"<li>{label}: <span class='{cls}'>{value}</span></li>"

    headers_html = "".join(
        f"<li>{k}: <span class='{'good' if v=='present' else 'bad'}'>{v}</span></li>"
        for k, v in (data.get("headers") or {}).items()
    ) or "<li class='muted'>No data</li>"

    leaks = data.get("leaks") or []
    leaks_html = ""
    for item in leaks:
        if isinstance(item, dict):
            for k, v in item.items():
                leaks_html += f"<li>{k}: <span class='bad'>{v}</span></li>"
    if not leaks_html:
        leaks_html = "<li class='good'>No obvious leakage headers found</li>"

    add = data.get("additional") or {}
    add_html = ""
    for k, v in add.items():
        add_html += f"<li>{k}: <span class='muted'>{v}</span></li>"
    if not add_html:
        add_html = "<li class='muted'>No additional checks</li>"

    recs = data.get("recommendations") or []
    recs_html = "".join(f"<li>{r}</li>" for r in recs) or "<li class='good'>All good ðŸŽ‰</li>"

    html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Hardening Auditor Report</title>
  <style>
:root { color-scheme: dark; }
body { font-family: Arial, sans-serif; background:#0b1220; color:#e5e7eb; padding:20px; }
.card { background:#0a1020; border:1px solid rgba(148,163,184,.12); padding:20px; border-radius:14px; max-width:900px; margin:0 auto; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
h1 { color:#38bdf8; margin:0 0 12px 0; }
h2 { margin-top:18px; }
.pill { display:inline-block; padding:10px 14px; border-radius:14px; background:rgba(2,6,23,.75); border:1px solid rgba(148,163,184,.12); margin:6px 0; }
.good { color:#4ade80; font-weight:700; }
.bad { color:#f87171; font-weight:700; }
small { color:#94a3b8; }
</style>
</head>
<body>
  <div class="card">
    <h1>Web Hardening Auditor</h1>

    <div class="pill"><b>Target:</b> {data.get('url','')}</div>
    <div class="pill"><b>Score:</b> {data.get('score',0)}/100</div>
    <div class="pill"><b>Time:</b> {data.get('timestamp','')}</div>

    <h2>Security headers</h2>
    <ul>{headers_html}</ul>

    <h2>Information leakage</h2>
    <ul>{leaks_html}</ul>

    <h2>Additional checks</h2>
    <ul>{add_html}</ul>

    <h2>Recommendations</h2>
    <ul>{recs_html}</ul>

    <div class="note">Note: This is a lightweight hardening auditor, not a full vulnerability scanner.</div>
  </div>
</body>
</html>
"""
    with open(path, "w", encoding="utf-8") as f:
        f.write(html)
def main():
    parser = argparse.ArgumentParser(description="Web Hardening Auditor")
    parser.add_argument("url", help="Target URL (https://example.com)")
    args = parser.parse_args()

    data = audit(args.url)

    ts = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
    json_path = f"reports/report_{ts}.json"
    html_path = f"reports/report_{ts}.html"

    with open(json_path, "w") as f:
        json.dump(data, f, indent=2)

    render_html(data, html_path)

    print("[+] Audit complete")
    print(f"[+] Score: {data['score']}/100")
    print(f"[+] JSON report: {json_path}")
    print(f"[+] HTML report: {html_path}")

if __name__ == "__main__":
    main()